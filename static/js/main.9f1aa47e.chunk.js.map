{"version":3,"sources":["AlgorithmVisualizer/Cell.jsx","algorithms/algorithm.js","algorithms/dijkstras.js","algorithms/breadth-first.js","algorithms/depth-first.js","AlgorithmVisualizer/AlgorithmVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Cell","drag","event","dataTransfer","setData","target","id","console","log","drop","document","getElementById","clearData","props","onMouseUp","allowDrop","bind","preventDefault","this","col","row","type","onMouseDown","onMouseEnter","onDrop","onDrag","onDragOver","className","draggable","cellType","START","END","Component","Algorithm","getAllCells","sortCellsByDistance","updateUnvisitedNeighbors","getUnvisitedNeighbors","unvisitedCells","sort","left","right","distance","cell","grid","unvisitedNeighbors","neighbor","weight","previousCell","neighbors","push","length","filter","isVisited","WALL","cells","end","path","current","unshift","Dijkstra","executeAlgorithm","getPath","start","visitedCells","shift","Infinity","BreadthFirst","queue","head","DepthFirst","stack","NORMAL","START_CELL_ROW","START_CELL_COL","END_CELL_ROW","END_CELL_COL","AlgorithmVisualizer","state","mouseIsPressed","movingStart","movingEnd","width","height","animating","algorithm","algorithmName","updateWindowDimensions","window","addEventListener","removeEventListener","oldGrid","newWidth","Math","floor","max","innerWidth","newHeight","innerHeight","generateGrid","setState","newGrid","toggleCellWall","resetBoard","startCell","endCell","animateAlgorithm","shortestPath","i","setTimeout","animateShortestPath","text","currentTarget","forEach","random","resetWalls","style","display","justifyContent","SplitButton","onClick","visualize","title","Dropdown","Item","as","padding","Button","map","rowIdx","key","cellIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createCell","slice","newCell","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.9f1aa47e.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport { cellType } from '../AlgorithmVisualizer/AlgorithmVisualizer.jsx'\n\nimport './Cell.css';\n\nexport default class Cell extends Component {\n  constructor() {\n    super();\n\n    this.allowDrop = this.allowDrop.bind(this);\n    this.drag = this.drag.bind(this);\n    this.drop = this.drop.bind(this);\n  }\n\n  allowDrop(event) {\n    event.preventDefault();\n  }\n\n  drag = (event) => {\n    event.dataTransfer.setData(\"text/plain\", event.target.id);\n    console.log(event.dataTransfer);\n  };\n\n  drop = (event) => {\n    if (event.target.id) {\n      event.target = document.getElementById(event.dataTransfer);\n      event.dataTransfer.clearData()\n    }\n    this.props.onMouseUp();\n  };\n\n  render() {\n    const {\n      col,\n      row,\n      type,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      //weight,\n    } = this.props;\n\n    return (\n      <>\n        <div\n          onDrop={this.drop}\n          onDrag={this.drag}\n          onDragOver={this.allowDrop}\n          id={`cell-${row}-${col}`}\n          className={`cell normal ${type}`}\n          draggable={(type === cellType.START || type === cellType.END)}\n          onMouseDown={() => onMouseDown(row, col)}\n          onMouseEnter={() => onMouseEnter(row, col)}\n          onMouseUp={() => onMouseUp()}></div>\n      </>\n    );\n  }\n}","import { cellType } from '../AlgorithmVisualizer/AlgorithmVisualizer.jsx'\n\nexport class Algorithm {\n    constructor() {\n        this.getAllCells = this.getAllCells.bind(this);\n        this.sortCellsByDistance = this.sortCellsByDistance.bind(this);\n        this.updateUnvisitedNeighbors = this.updateUnvisitedNeighbors.bind(this);\n        this.getUnvisitedNeighbors = this.getUnvisitedNeighbors.bind(this);\n    }\n\n    sortCellsByDistance(unvisitedCells) {\n        unvisitedCells.sort((left, right) => left.distance - right.distance);\n    }\n\n    updateUnvisitedNeighbors(cell, grid) {\n        const unvisitedNeighbors = this.getUnvisitedNeighbors(cell, grid);\n        for (const neighbor of unvisitedNeighbors) {\n            neighbor.distance = cell.distance + neighbor.weight;\n            neighbor.previousCell = cell;\n        }\n    }\n\n    getUnvisitedNeighbors(cell, grid) {\n      let neighbors = [];\n      const {col, row} = cell;\n      if (row > 0) neighbors.push(grid[row - 1][col]);\n      if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n      if (col > 0) neighbors.push(grid[row][col - 1]);\n      if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\n      return neighbors.filter(neighbor => !neighbor.isVisited && !(neighbor.type === cellType.WALL));\n    }\n\n    getAllCells(grid) {\n        const cells = [];\n        for (const row of grid) {\n            for (const cell of row) {\n                cells.push(cell);\n            }\n        }\n        return cells;\n    }\n\n    getPath(end) {\n        const path = [];\n        let current = end;\n        while (current !== null) {\n            path.unshift(current);\n            current = current.previousCell;\n        }\n        return path;\n    }\n}","import {Algorithm} from './algorithm';\n\nexport class Dijkstra extends Algorithm {\n    constructor() {\n        super();\n        this.executeAlgorithm = this.executeAlgorithm.bind(this);\n        this.getPath = this.getPath.bind(this);\n    }\n\n    executeAlgorithm(grid, start, end) {\n        let visitedCells = [];\n        start.distance = 0;\n        const unvisitedCells = this.getAllCells(grid);\n        while (!!unvisitedCells.length) {\n            this.sortCellsByDistance(unvisitedCells);\n            const neighbor = unvisitedCells.shift();\n            if (neighbor.distance === Infinity) {\n                return visitedCells;\n            }\n            neighbor.isVisited = true;\n            visitedCells.push(neighbor);\n            if (neighbor === end) {\n                return visitedCells;\n            }\n            this.updateUnvisitedNeighbors(neighbor, grid);\n        }\n    }\n}","import {Algorithm} from './algorithm';\n\nexport class BreadthFirst extends Algorithm {\n    constructor() {\n        super();\n        this.executeAlgorithm = this.executeAlgorithm.bind(this);\n    }\n\n    executeAlgorithm(grid, start, end) {\n        let visitedCells = [];\n        start.isVisited = true;\n        let queue = [start];\n\n        while (!!queue.length) {\n            const head = queue.shift()\n\n            //document.getElementById(`cell-${neighbor.row}-${neighbor.col}`).className =\n              //`cell normal ${neighbor.type} visited`;\n            visitedCells.push(head);\n            if (head === end) {\n                return visitedCells;\n            }\n\n            this.updateUnvisitedNeighbors(head, grid);\n            for (let neighbor of this.getUnvisitedNeighbors(head, grid)) {\n              neighbor.isVisited = true;\n              queue.push(neighbor);\n            }\n        }\n\n        return visitedCells;\n    }\n}","import {Algorithm} from './algorithm';\n\nexport class DepthFirst extends Algorithm {\n    constructor() {\n        super();\n        this.executeAlgorithm = this.executeAlgorithm.bind(this);\n    }\n\n    executeAlgorithm(grid, start, end) {\n      let visitedCells = [];\n      let stack = [start];\n\n      while (!!stack.length) {\n        let head = stack.shift();\n\n        if (!head.isVisited) {\n          head.isVisited = true;\n          visitedCells.push(head);\n          if (head === end) {\n            return visitedCells;\n          }\n\n          this.updateUnvisitedNeighbors(head, grid);\n          for (let neighbor of this.getUnvisitedNeighbors(head, grid)) {\n            stack.unshift(neighbor);\n          }\n        }\n      }\n\n      return visitedCells;\n    }\n}","import React, {Component} from 'react';\nimport SplitButton from 'react-bootstrap/SplitButton'\nimport Dropdown from 'react-bootstrap/Dropdown'\nimport Button from 'react-bootstrap/Button';\n\nimport Cell from './Cell';\nimport {Dijkstra} from '../algorithms/dijkstras';\nimport {BreadthFirst} from '../algorithms/breadth-first';\nimport {DepthFirst} from '../algorithms/depth-first';\n\nimport './AlgorithmVisualizer.css';\n\nexport const cellType = {\n    START: 'start',\n    END: 'end',\n    WALL: 'wall',\n    NORMAL: 'normal'\n};\n\nlet START_CELL_ROW = -1;\nlet START_CELL_COL = -1;\nlet END_CELL_ROW = -1;\nlet END_CELL_COL = -1;\n\nexport default class AlgorithmVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      movingStart:  false,\n      movingEnd: false,\n      width: 0,\n      height: 0,\n      animating: false,\n      algorithm: new Dijkstra(),\n      algorithmName: \"Dijkstra's\",\n    };\n    this.updateWindowDimensions = this.updateWindowDimensions.bind(this);\n  }\n\n  componentDidMount() {\n    this.updateWindowDimensions();\n    window.addEventListener('resize', this.updateWindowDimensions);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.updateWindowDimensions);\n  }\n\n  updateWindowDimensions(oldGrid=null) {\n    const {animating, width, height} = this.state;\n    const newWidth = Math.floor(Math.max(window.innerWidth - 15, 0) / 25);\n    const newHeight = Math.floor(Math.max(window.innerHeight - 125, 0) / 25);\n\n    if (END_CELL_ROW === START_CELL_ROW && START_CELL_COL === END_CELL_COL && START_CELL_COL === -1) {\n        END_CELL_ROW = START_CELL_ROW = Math.floor(newHeight / 2);\n        START_CELL_COL = Math.floor(newWidth / 3);\n        END_CELL_COL = Math.floor(newWidth / 3) * 2;\n    }\n\n    if (!animating && width !== newWidth && height !== newWidth) {\n      const grid = generateGrid(Math.max(START_CELL_COL+1, END_CELL_COL+1, newWidth),\n          Math.max(START_CELL_ROW, END_CELL_ROW, newHeight), oldGrid);\n      this.setState({ width: newWidth, height: newHeight, grid });\n    }\n  }\n\n  handleMouseDown(row, col) {\n    const { grid } = this.state;\n    let newGrid = toggleCellWall(grid, row, col);\n    this.setState({grid: newGrid, mouseIsPressed: true});\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = toggleCellWall(this.state.grid, row, col);\n    this.setState({grid: newGrid});\n  }\n\n  handleMouseUp() {\n    this.setState({mouseIsPressed: false});\n  }\n\n  visualize() {\n    this.resetBoard();\n    let {grid, algorithm} = this.state;\n    this.updateWindowDimensions(grid);\n    const startCell = grid[START_CELL_ROW][START_CELL_COL];\n    const endCell = grid[END_CELL_ROW][END_CELL_COL];\n    const visitedCells = algorithm.executeAlgorithm(grid, startCell, endCell);\n    const path = algorithm.getPath(endCell);\n    this.animateAlgorithm(visitedCells, path);\n  }\n\n  animateAlgorithm(visitedCells, shortestPath) {\n    this.setState({ animating: true })\n    for (let i = 0; i <= visitedCells.length; i++) {\n      if (i === visitedCells.length) {\n        setTimeout(() => {\n          this.animateShortestPath(shortestPath);\n        }, 1000 + 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const cell = visitedCells[i];\n        document.getElementById(`cell-${cell.row}-${cell.col}`).className =\n          `cell normal ${cell.type} visited`;\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(shortestPath) {\n    for (let i = 0; i < shortestPath.length; i++) {\n      setTimeout(() => {\n        const cell = shortestPath[i];\n        document.getElementById(`cell-${cell.row}-${cell.col}`).className =\n          `cell normal ${cell.type} shortest-path`;\n      }, 50 * i);\n    }\n    this.setState({ animating: false })\n  }\n\n  swapAlgorithm(event) {\n    event.preventDefault();\n    var anchor = event.currentTarget;\n    var text = anchor.text;\n    var button = document.getElementById(\"visualize\");\n    button.text = text;\n    //button.on('click', this.visualize());\n  }\n\n  distributeWeights() {\n    const { grid } = this.state\n    grid.forEach((row) => {\n      row.forEach((cell) => {\n        cell.weight = Math.floor(Math.random() * 10) + 1;\n      })\n    })\n  }\n\n  resetBoard(resetWalls=false) {\n    let {grid} = this.state;\n    grid.forEach((row) => {\n        row.forEach((cell) => {\n          document.getElementById(`cell-${cell.row}-${cell.col}`).className = `cell normal ${cell.type}`;\n          cell.isVisited = false;\n          if (resetWalls) {\n            if (cell.type === cellType.WALL) {\n              cell.className = `cell normal`;\n              cell.type = cellType.NORMAL;\n            }\n          }\n        })\n    });\n\n    this.setState({ grid })\n  }\n\n  render() {\n    const {grid, mouseIsPressed} = this.state;\n\n    return (\n        <>\n        <div style={{display: 'flex', justifyContent: 'center'}}>\n          <SplitButton onClick={() => this.visualize()} id=\"dropdown-item-button\" title={`Visualize ${this.state.algorithmName}`}>\n            <Dropdown.Item onClick={() => this.setState({algorithm: new Dijkstra(), algorithmName: \"Dijkstra's\"})} as=\"button\">Dijkstra's</Dropdown.Item>\n            <Dropdown.Item onClick={() => this.setState({algorithm: new BreadthFirst(), algorithmName: \"Breadth-First Search\"})} as=\"button\">Breadth-First Search</Dropdown.Item>\n            <Dropdown.Item onClick={() => this.setState({algorithm: new DepthFirst(), algorithmName: \"Depth-First Search\"})} as=\"button\">Depth-First Search</Dropdown.Item>\n          </SplitButton>\n          <div style={{padding: '4px'}}/>\n          <Button onClick={() => this.resetBoard(true)}>\n            Reset\n          </Button>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((cell, cellIdx) => {\n                  const {row, col, type, weight} = cell;\n                  return (\n                    <Cell\n                      key={cellIdx}\n                      col={col}\n                      row={row}\n                      type={type}\n                      weight={weight}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}>\n                    </Cell>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n\nconst generateGrid = (width, height, oldGrid=null) => {\n  const grid = [];\n  for (let row = 0; row < height; row++) {\n    const currentRow = [];\n    for (let col = 0; col < width; col++) {\n      if (oldGrid && col <= oldGrid[0].length && row <= oldGrid.length) {\n        currentRow.push(oldGrid[row][col]);\n      } else if (col === START_CELL_COL && row === START_CELL_ROW) {\n        currentRow.push(createCell(col, row, cellType.START));\n      } else if (col === END_CELL_COL && row === END_CELL_ROW) {\n        currentRow.push(createCell(col, row, cellType.END));\n      } else {\n        currentRow.push(createCell(col, row, cellType.NORMAL));\n      }\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createCell = (col, row, type) => {\n  return {\n    col,\n    row,\n    type: type,\n    weight: 1,\n    distance: Infinity,\n    isVisited: false,\n    previousCell: null,\n  };\n};\n\nconst toggleCellWall = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const cell = newGrid[row][col];\n  const newCell = {\n    ...cell,\n    type: (cell.type === cellType.NORMAL ? cellType.WALL: cell.type) ||\n    (cell.type === cellType.WALL ? cellType.NORMAL : cell.type),\n  };\n  newGrid[row][col] = newCell;\n  return newGrid;\n};","import React from 'react';\nimport AlgorithmVisualizer from './AlgorithmVisualizer/AlgorithmVisualizer';\nimport './App.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nfunction App() {\n  return (\n    <AlgorithmVisualizer></AlgorithmVisualizer>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}